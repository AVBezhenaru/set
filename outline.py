11. Множества
В прошлый раз мы рассмотрели, как хэш-таблицы расширить до концепции словарей. Однако существует одно полезное применение хэш-таблиц самих по себе -- это так называемые множества.

В Python множества реализованы как тип данных set. Это просто неупорядоченное хранилище данных -- мы даже не можем обратиться к нему для извлечения значения по ключу или индексу. Его ключевая особенность -- каждое значение хранится в нём в единичном экземпляре.

Мы можем определить множество из нескольких значений так:

a = {1024, '512', 3.14}
Следующая запись хоть и считается корректной, однако в переменной a всё равно окажется лишь три значения:

a = {1024, '512', 3.14, 3.14} # {1024, '512', 3.14}
Поэтому в частности множества удобно использовать для исключения дублирующих значений.

Главный плюс множества -- это высокая скорость проверки, принадлежит ли элемент множеству, её сложность O(1).

На основе класса HashTable создайте реализующий множество класс PowerSet, который во-первых не должен допускать добавление уже существующего в множестве значения -- надо изменить оригинальный метод put().

Во-вторых, дополнительно реализуем следующие типичные для множества методы:

- remove(значение) -- удаление элемента из множества;

- intersection(), в качестве параметра выступает другое множество, а возвращается пересечение этих множеств (множество, в котором есть только те элементы, которые имеются в каждом из множеств);

- union(), в качестве параметра выступает другое множество, а возвращается объединение этих множеств (множество, в котором есть все элементы из каждого множества);

- difference(), в качестве параметра выступает другое множество, а возвращается подмножество текущего множества из таких элементов, которые не входят в множество-параметр;

- issubset(), в качестве параметра выступает другое множество, и проверяется, входят ли все его элементы в текущее множество (будет ли множество-параметр подмножеством текущего множества).

3. Добавьте тесты, которые проверяют:
- возможность добавления отсутствующего элемента и невозможность добавления присутствующего в множестве элемента с помощью put();
- удаление элемента с помощью remove();
- пересечение множеств intersection(), чтобы в результате получались как пустое, так и непустое множества;
- объединение union(), когда оба параметра непустые, и когда один из параметров -- пустое множество;
- разница difference(), чтобы в результате получались как пустое, так и непустое множества;
- подмножество issubset() -- рассмотрите три случая (все элементы параметра входят в текущее множество, все элементы текущего множества входят в параметр, не все элементы параметра входят в текущее множество).

заготовка класса для автоматической проверки
Как правильно подготовить ваш код для автоматической проверки

# наследуйте этот класс от HashTable
# или расширьте его методами из HashTable
class PowerSet:

    def __init__(self):
        # ваша реализация хранилища

    def size(self):
        return 0
        # количество элементов в множестве

    def put(self, value):
        # всегда срабатывает

    def get(self, value):
        # возвращает True если value имеется в множестве,
        # иначе False
        return False

    def remove(self, value):
        # возвращает True если value удалено
        # иначе False
        return False

    def intersection(self, set2):
        # пересечение текущего множества и set2
        return None

    def union(self, set2):
        # объединение текущего множества и set2
        return None

    def difference(self, set2):
        # разница текущего множества и set2
        return None

    def issubset(self, set2):
        # возвращает True, если set2 есть
        # подмножество текущего множества,
        # иначе False
        return False